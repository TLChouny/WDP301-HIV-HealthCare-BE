const Booking = require('../models/Booking'); // ƒêi·ªÅu ch·ªânh l·∫°i path ƒë√∫ng theo d·ª± √°n c·ªßa b·∫°n
const Service = require('../models/Service'); // ƒê·∫£m b·∫£o model n√†y t·ªìn t·∫°i
const Notification = require('../models/Notification');
const User = require('../models/User'); 

const mongoose = require('mongoose');
// Generate 6-digit random booking code
const generateRandomSixDigitNumber = () => {
  return String(Math.floor(Math.random() * 900000) + 100000);
};

// T√≠nh th·ªùi gian k·∫øt th√∫c d·ª±a v√†o startTime v√† duration (ph√∫t)
const calculateEndTime = (startTime, duration) => {
  const [hour, minute] = startTime.split(':').map(Number);
  const date = new Date();
  date.setHours(hour, minute, 0, 0);
  date.setMinutes(date.getMinutes() + duration);
  return date.toTimeString().slice(0, 5); // Format: HH:mm
};

// T·∫°o danh s√°ch slot theo kho·∫£ng th·ªùi gian
const generateTimeSlotsInRange = (startTime, endTime, interval = 30) => {
  const slots = [];
  const [startHour, startMinute] = startTime.split(':').map(Number);
  const [endHour, endMinute] = endTime.split(':').map(Number);

  let currentTime = new Date();
  currentTime.setHours(startHour, startMinute, 0, 0);

  const endTimeDate = new Date();
  endTimeDate.setHours(endHour, endMinute, 0, 0);

  while (currentTime < endTimeDate) {
    slots.push(
      `${currentTime.getHours().toString().padStart(2, '0')}:${currentTime.getMinutes().toString().padStart(2, '0')}`
    );
    currentTime.setMinutes(currentTime.getMinutes() + interval);
  }

  return slots;
};

// üìå API ki·ªÉm tra c√°c khung gi·ªù ƒë√£ ƒë∆∞·ª£c ƒë·∫∑t c·ªßa b√°c sƒ© trong ng√†y
exports.checkExistingBookings = async (req, res) => {
  try {
    const { doctorName, bookingDate } = req.query;

    if (!doctorName || !bookingDate) {
      return res.status(400).json({ message: 'Missing doctorName or bookingDate parameter' });
    }

    console.log('üîç Received query:', { doctorName, bookingDate });

    const bookings = await Booking.find({ doctorName, bookingDate }).populate('serviceId');
    console.log('üì¶ Found bookings:', bookings.length);

    const bookedSlots = new Set();

    for (const booking of bookings) {
      let startTime = booking.startTime;
      let endTime = booking.endTime;

      // ∆Øu ti√™n l·∫•y duration t·ª´ serviceId, fallback d√πng booking.duration n·∫øu c√≥
      let duration =
        (booking.serviceId && booking.serviceId.duration) ||
        booking.duration;

      // N·∫øu kh√¥ng c√≥ endTime ‚Üí t·ª± t√≠nh t·ª´ startTime + duration
      if (!endTime && startTime && duration) {
        endTime = calculateEndTime(startTime, duration);
      }

      if (startTime && endTime) {
        const slots = generateTimeSlotsInRange(startTime, endTime);
        slots.forEach((slot) => bookedSlots.add(slot));
      } else {
        console.warn(`‚ö†Ô∏è Missing time data in booking ${booking._id}`);
      }
    }

    console.log('‚è±Ô∏è Booked slots:', [...bookedSlots]);
    res.status(200).json([...bookedSlots]);
  } catch (error) {
    console.error('‚ùå Error in checkExistingBookings:', error);
    res.status(500).json({ message: 'Internal server error' });
  }
};


// üìå T·∫°o booking m·ªõi
exports.create = async (req, res) => {
  try {
    const {
      userId,
      serviceId,
      doctorName,
      bookingDate,
      startTime,
      endTime,
      customerName,
      customerPhone,
      customerEmail,
      notes,
      isAnonymous,
      status
    } = req.body;

    if (!serviceId || !bookingDate || !startTime || (!isAnonymous && (!customerName || !customerPhone || !customerEmail))) {
      return res.status(400).json({ message: "Missing required fields" });
    }

    const service = await Service.findById(serviceId);
    if (!service) return res.status(404).json({ message: "Service not found" });

    // üí• Ki·ªÉm tra xung ƒë·ªôt l·ªãch
    const isConflict = await Booking.findOne({
      doctorName,
      bookingDate,
      startTime
    });

    if (isConflict) {
      return res.status(409).json({
        message: "Doctor already has a booking at this time."
      });
    }

    const realEndTime = endTime || calculateEndTime(startTime, service.duration || 30);

    let bookingCode;
    let isUnique = false;
    while (!isUnique) {
      const code = `BOOK-${generateRandomSixDigitNumber()}`;
      const existing = await Booking.findOne({ bookingCode: code });
      if (!existing) {
        bookingCode = code;
        isUnique = true;
      }
    }

    const newBooking = new Booking({
      userId: userId || null,
      serviceId,
      serviceName: service.name,
      bookingDate,
      startTime,
      endTime: realEndTime,
      doctorName: doctorName || null,
      customerName: isAnonymous ? undefined : customerName,
      customerPhone: isAnonymous ? undefined : customerPhone,
      customerEmail: isAnonymous ? undefined : customerEmail,
      notes,
      isAnonymous: !!isAnonymous,
      status: status || "pending",
      bookingCode
    });

    const savedBooking = await newBooking.save();

    // T·∫°o notification t·ª± ƒë·ªông
    if (savedBooking._id) {
      await Notification.create({
        notiName: 'ƒê·∫∑t l·ªãch th√†nh c√¥ng',
        notiDescription: 'B·∫°n ƒë√£ ƒë·∫∑t l·ªãch th√†nh c√¥ng!',
        bookingId: savedBooking._id,
        userId: userId || null, // G√°n userId n·∫øu c√≥
      }).catch(err => {
        console.error('‚ùå Error creating notification:', err);
      });
    }

    res.status(201).json(savedBooking);
  } catch (error) {
    console.error('‚ùå Error in create booking:', error);
    res.status(500).json({ message: error.message });
  }
};

// üìå Get all bookings
exports.getAll = async (req, res) => {
  try {
    const bookings = await Booking.find()
      .populate('serviceId') // L·∫•y to√†n b·ªô field c·ªßa service
      .populate('userId');   // L·∫•y to√†n b·ªô field c·ªßa user

    // Tr·∫£ v·ªÅ to√†n b·ªô object serviceId v√† userId
    const transformedBookings = bookings.map(booking => ({
      _id: booking._id,
      bookingCode: booking.bookingCode,
      customerName: booking.customerName,
      customerPhone: booking.customerPhone,
      customerEmail: booking.customerEmail,
      serviceId: booking.serviceId, // Tr·∫£ v·ªÅ to√†n b·ªô object service
      userId: booking.userId,       // Tr·∫£ v·ªÅ to√†n b·ªô object user
      bookingDate: booking.bookingDate,
      startTime: booking.startTime,
      endTime: booking.endTime,
      doctorName: booking.doctorName,
      status: booking.status,
      meetLink: booking.meetLink,
      doctorNote: booking.doctorNote,
      isAnonymous: booking.isAnonymous,
      notes: booking.notes
    }));

    res.status(200).json(transformedBookings);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// üìå Get bookings by UserID
exports.getBookingsByUserId = async (req, res) => {
  try {
    const { userId } = req.params;
    if (!userId) {
      return res.status(400).json({ message: "Missing userId parameter" });
    }

    const bookings = await Booking.find({ userId })
      .populate('serviceId')
      .populate('userId');
    if (!bookings || bookings.length === 0) {
      return res.status(404).json({ message: 'No bookings found for this user' });
    }

    res.status(200).json(bookings);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// üìå Get bookings by doctorName
exports.getBookingsByDoctorName = async (req, res) => {
  try {
    const { doctorName } = req.params;
    if (!doctorName) {
      return res.status(400).json({ message: "Missing doctorName parameter" });
    }

    const bookings = await Booking.find({ doctorName })
      .populate('serviceId')
      .populate('userId');
    if (!bookings || bookings.length === 0) {
      return res.status(404).json({ message: 'No bookings found for this doctor' });
    }

    res.status(200).json(bookings);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// üìå Get booking by ID
exports.getById = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id).populate('serviceId').populate('userId');
    if (!booking) return res.status(404).json({ message: 'Booking not found' });
    res.status(200).json(booking);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

// üìå Update booking
exports.updateById = async (req, res) => {
  try {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
      return res.status(400).json({ message: 'Invalid booking ID' });
    }

    const urlRegex = /^(https?:\/\/)?([\w-]+(\.[\w-]+)+)([\w.,@?^=%&:/~+#-]*[\w@?^=%&/~+#-])?$/;
    if (req.body.meetLink && !urlRegex.test(req.body.meetLink)) {
      return res.status(400).json({ message: 'Invalid meetLink URL' });
    }

    const booking = await Booking.findByIdAndUpdate(
      id,
      req.body,
      { new: true, runValidators: true }
    );
    if (!booking) return res.status(404).json({ message: 'Booking not found' });

    // ‚úÖ Khi staff c·∫≠p nh·∫≠t meetLink
    if (req.body.meetLink) {
      try {
        if (booking.userId) {
          await Notification.create({
            notiName: 'Link t∆∞ v·∫•n ƒë√£ s·∫µn s√†ng',
            notiDescription: `Link Google Meet: ${req.body.meetLink}`,
            userId: booking.userId,
            bookingId: booking._id
          });
        }

        if (booking.doctorName) {
          const doctorUser = await User.findOne({ doctorName: booking.doctorName });
          if (doctorUser) {
            await Notification.create({
              notiName: 'L·ªãch t∆∞ v·∫•n m·ªõi',
              notiDescription: `B·∫°n c√≥ l·ªãch t∆∞ v·∫•n v·ªõi link: ${req.body.meetLink}`,
              userId: doctorUser._id,
              bookingId: booking._id
            });
          } else {
            console.warn(`Doctor with name ${booking.doctorName} not found`);
          }
        }

        // C·∫≠p nh·∫≠t status th√†nh "checked-in"
        booking.status = "checked-in";
        await booking.save();
        console.log(`üîÑ Status updated to "checked-in" for booking ${booking._id}`);

      } catch (notiError) {
        console.error('Notification creation failed:', notiError.message);
      }
    }
    // ‚úÖ N·∫øu c√≥ doctorNote v√† booking ƒë√£ checked-in ‚Üí c·∫≠p nh·∫≠t status th√†nh completed
if (req.body.doctorNote && booking.status === "checked-in") {
  booking.status = "completed";
  await booking.save();
  console.log(`‚úÖ ƒê√£ c·∫≠p nh·∫≠t status => completed cho booking ${booking._id} v√¨ ƒë√£ c√≥ doctorNote`);
    // G·ª≠i th√¥ng b√°o cho user
      if (booking.userId) {
        try {
          await Notification.create({
            notiName: 'Bu·ªïi t∆∞ v·∫•n ƒë√£ ho√†n t·∫•t',
            notiDescription: 'N·ªôi dung t∆∞ v·∫•n ƒë√£ ƒë∆∞·ª£c g·ª≠i. C·∫£m ∆°n b·∫°n ƒë√£ tham gia bu·ªïi t∆∞ v·∫•n!',
            userId: booking.userId,
            bookingId: booking._id
          });
        } catch (err) {
          console.error("‚ùå Failed to create completion notification:", err.message);
        }
      }
}
    res.status(200).json(booking);
  } catch (error) {
    console.error('Update booking error:', error);
    if (error.name === 'ValidationError') {
      return res.status(400).json({ message: 'Validation error', details: error.errors });
    }
    res.status(400).json({ message: error.message || 'Internal server error' });
  }
};


// üìå Delete booking
exports.deleteById = async (req, res) => {
  try {
    const booking = await Booking.findByIdAndDelete(req.params.id);
    if (!booking) return res.status(404).json({ message: 'Booking not found' });
    res.status(200).json({ message: 'Booking deleted successfully' });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};